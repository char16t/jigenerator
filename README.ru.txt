Генератор интерпретаторов

Некоторое время назад интереса ради я написал этот небольшой генератор
интерпретаторов. Фактически, это генератор лексера, LL(1)-парсера и
заготовки интерпретатора на языке Java. Он не пертендует на большую серьёзность,
использует несколько странный язык описания грамматик, но тем не менее работает.
На момент написания этого кода я прочитал несколько конспектов лекций зарубежных
технических ВУЗов по парсингу формальных языков. Я не думаю, что это может быть
как-то полезно в реальном применении, но я получил интересный опыт и вы можете
рассматривать это как прототип. Я не планирую далее поддерживать это, но тем
не менее я с удовольствием рассмотрю ваши вопросы и предложения в виде Pull
Request'ов на GitHub и в виде патчей на почту v@manenkov.com. Для реального
применения используйте ANTLR.

СБОРКА
======

    Для сборки с помощью Maven используйте команду:

        mvn clean package

    Директория target будет содержать файл interpreter-1.0-SNAPSHOT.jar

ЗАПУСК И ИСПОЛЬЗОВАНИЕ
======================

    На вход программа принимает файл с описанием грамматик на специальном языке
    и директорию, в которую следует положить файлы сгенерированной заготовки
    интерпретатора на Java.

        java -jar interpreter-1.0-SNAPSHOT.jar myGrammars.txt output

    На выходе вы получаете директорию output с заготовкой парсера. Вам остаётся
    заполнить методы класса Interpreter.java, чтобы определить поведение при
    посещении интерпретатором различных типов узлов AST-дерева.

    Для демонстрационного запуска прямо из IDE вы можете использовать тест
    MainTest и получить сгенерированный код во временной директории вашей
    операционной ситемы. Вы также можете посмотреть пример сгенерированного
    (и отформатированного вручную) кода прямо в репозитории с исходным кодом.

ЯЗЫК ОПИСАНИЯ ГРАММАТИК
=======================

    Я покажу язык на примере парсера арифметических выражений. Его полный код
    выглядит следующим образом:

        expr   := term[a] *((PLUS[b] | MINUS[b]) term[c] #BinOp(a, b, c)[a]) $a;
        term   := factor[d] *((MUL[e] | DIV[e]) factor[f] #BinOp(d, e, f)[d]) $d;
        factor := (PLUS[a] | MINUS[a]) factor[b] #UnaryOp(a,b)[c] $c;
        factor := INTEGER[d] #Num(d)[e] $e;
        factor := LPAREN expr[f] RPAREN $f;

        PLUS := '+';
        MINUS := '-';
        MUL := '*';
        DIV := '/';
        EQ := ':=';
        LPAREN := '(';
        RPAREN := ')';
        INTEGER := ('0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9') *('0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9');

        @BinOp(%n, %t, %n);
        @UnaryOp(%t, %n);
        @Num(%t);

    В данном случае сначала определена секция грамматик парсера, затем
    определения лексем для лексера и секция с определениями узлов AST-дерева.
    Порядок следования секций должен быть именно таким как в примере и вы должны
    соблюдать следующие правила:

     - Нетерминалы сосотят только из строчных букв. В примере выше это expr,
       term и factor.

     - Терминалы состоят только из заглавных букв. В примере выше это PLUS,
       MINUS, MUL, DIV и так далее.

     - Конструкция вида *( <expression> ) означает повторение выражения
       <expression> ноль или более раз.

     - Возможные значения для нетерминалов записываются в одинарных кавычках.

     - Конструкция вида <expr1> | <expr2> означает ИЛИ.

     - Вы можете свободно использовать скобки для установки приоритета операций.

     - Определения узлов AST-дерева начинаются с символа "@", а затем следует их
       имя. Оно будет транслировано в  Java код как есть, поэтому в соответствии
       с соглашением именования Java-классов используйте CamelCase стиль.

     - Аргументы, описываемые в скообках определяют тип дочерних узов для
       описываемого узла. Это могут быть терминалы(%t) или нетерминалы(%n).
       Например, определение бинарной операции выглядит как @BinOp(%n, %t, %n)
       Это значит, что узел BinOp AST-дерева должен содержать два нетерминала
       (операнды) и один терминал (операцию).

     - Создание узлов AST-дерева для описанных типов начинается с символа #, а
       затем следует имя, которое будет транслировано в Java-код как есть. В
       примере выше это #BinOp(a, b, c). В этом примере прямо за созданием узла
       BinOp следует имя локальной переменной в квадратных скобках. Об этом
       можно прочитать ниже.

     - Локальные имена для нетерминалов и терминалов записываются в квадратных
       скобках. В примере выше вы можете видеть  term[a] и PLUS[b]. Позже эти
       имена будут использованы при создании узла дерева #BinOp(a, b, c).

     - Возврат значения из метода (в действительности, все нетерминалы будут
       транслированы в методы Java-классов) можно осуществить с помощью
       конструкции вида $v, где v - имя меременной. Примеры вы можете увидеть в
       конце каждого нетерминала из примера.

     - Вы можете записывать последовательно несколько продукций с одинаковым
       именем, в таком случае правило будет интерпретировано как

         <тело1> | <тело2> | ... | <телоN>

       В примере выше вы можете видеть это в продукции factor.

     Насколько я могу вспомнить, это всё, что поддерживается языке описания
     грамматик на данный момент. Посмотрите ещё раз на грамматики для парсера:

        expr   := term[a] *((PLUS[b] | MINUS[b]) term[c] #BinOp(a, b, c)[a]) $a;
        term   := factor[d] *((MUL[e] | DIV[e]) factor[f] #BinOp(d, e, f)[d]) $d;
        factor := (PLUS[a] | MINUS[a]) factor[b] #UnaryOp(a,b)[c] $c;
        factor := INTEGER[d] #Num(d)[e] $e;
        factor := LPAREN expr[f] RPAREN $f;

     Выглядит громоздко, но можно заметить некоторое сходство с более наглядной
     канонической формой записи:

        expr   := term *((PLUS | MINUS) term);
        term   := factor *((MUL | DIV) factor);
        factor := (PLUS | MINUS) factor | INTEGER | LPAREN expr RPAREN;

     Такой вариант синтаксиса также является корректным будет правильно
     транслирован в Java-код, однако вам придётся самостоятельно дописать
     операторы возврата и записать результаты полученные от AST-поддеревьев в
     локальные переменные.

     Остальные части этого парсера выражений разобраны в описании языковых
     конструкций. Если хочется понять как это работает, посмторите внимательнее
     на код или на сгенерированный Java-код в этом репозитории в директории с
     примером. Вы можете установить точку останова и просмотреть полученное
     дерево в IDE.

СГЕНЕРИРОВАННЫЙ ИСХОДНЫЙ КОД
============================

    В результате вы получаете Java-проект со следующими файлами:

    - AST.java          Абстрактный узел AST-дерева
    - AST*.java         Набор классов, соответствующих типам узлов вашего дерева
    - Lexer.java        Лексер (полностью готовый)
    - Parser.java       Парсер (полностью готовый)
    - Token.java        Класс "Лексема". Требуется для лексера
    - TokenType.java    Перечисление типов лексем
    - Interpreter.java  Заготовка класса "Интерпретатор". Требудется опеределние
                        поведения во время проождения по AST-дереву. Просто
                        задайте это поведение в методах этого класса.


ГРАММАТИКИ ЯЗЫКА ОПИСАНИЯ ГРАММАТИК
===================================

    Это почти точные грамматики языка описания грамматик, которые я восстановил
    по памяти. Вы можете проверить их по исходному коду в случае любых связанных
    с этим вопросов.

        program := (rule)* (termdef)* (astdef)*

        rule    := nonterm EQ expr SEMI
        expr    := (expr2)* (LINE expr)*
        expr2   := expr3 | STAR LPAREN expr3 (expr)* RPAREN
        expr3   := atom | LPAREN expr RPAREN
        atom    := nonterm | term | call | RET
        nonterm := NONTERM (NAME | EMPTY)
        call    := CALL (NAME | EMPTY)

        termdef     := term EQ termexpr SEMI
        termexpr    := (termexpr2)* (LINE termexpr)*
        termexpr2   := termexpr3 | STAR LPAREN termexpr3 (termexpr)* RPAREN
        termexpr3   := termatom | LPAREN termexpr RPAREN
        termatom    := SQ <any symbols except single quote> SQ
        term        := TERM (NAME | EMPTY)

        astdef := ASTNAME LPAREN INTEGER RPAREN SEMI

        SQ  := '\''
        ASTNAME := '@' ('a'..'z' | 'A'..'Z')*
        LPAREN  := '('
        RPAREN  := ')'
        SEMI    := ';'
        NAME    := '[' ('a'..'z' | 'A'..'Z')* ']'
        COMMA   := ','
        EMPTY   := ''
        WORD    := ('a'..'z' | 'A'..'Z')*
        INTEGER := ('0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9') ('0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9')*

ЛИЦЕНЗИЯ
========

MIT



                                                                        Валерий,
                                                            v.manenkov@gmail.com
                                                           http://v.manenkov.com